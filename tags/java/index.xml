<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on 元代码</title><link>https://yuancode.net/tags/java/</link><description>Recent content in Java on 元代码</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sun, 07 Aug 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://yuancode.net/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>[JVM] Java的类加载机制</title><link>https://yuancode.net/post/java/draftjvm_classloader/</link><pubDate>Sun, 07 Aug 2022 00:00:00 +0000</pubDate><guid>https://yuancode.net/post/java/draftjvm_classloader/</guid><description>&lt;p>&lt;strong>Java的类加载机制&lt;/strong>&lt;/p>
&lt;p>一般，Java的类加载过程分为三个主要步骤：加载、连接、初始化。&lt;/p>
&lt;ol>
&lt;li>加载（Loading），将字节码数据从不同的数据源读取到JVM中，并映射为JVM认可的数据结构（Class对象），数据源可能是jar文件、class文件甚至网络数据源。如果输入数据不是ClassFile结构，则会抛出&lt;code>ClassFromatError&lt;/code>。
&lt;ul>
&lt;li>加载阶段是用户参与的阶段，我们可以自定义类加载器，实现自己的类加载过程。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>连接（Linking），是核心步骤，把原始的类定义信息平滑的转化到JVM运行的过程中。可以进一步分为三个步骤：
&lt;ol>
&lt;li>验证（Verification），虚拟机安全的重要保障，验证字节信息是否符合Java虚拟机规范，否则被认为是&lt;code>VerifyError&lt;/code>，防止恶意信息或不合规的信息危害JVM的运行。&lt;/li>
&lt;li>准备（Preparation），创建类或接口中的静态变量，并初始化静态变量的初始值。==侧重点在于分配所需的内存空间，不会执行进一步的JVM指令。==&lt;/li>
&lt;li>解析（Resolution），将常量池中的符号引用（symbolic reference）替换为直接引用。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>初始化（initialization），真正去执行类初始化的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态初始化块内的逻辑，编译器在编译阶段就会把这部分逻辑整理好，父类型的初始化逻辑优先于当前类型的逻辑。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>关于双亲委派模型：&lt;/strong>&lt;/p>
&lt;p>简单说就是当类加载器（Class-Loader）试图加载某个类型的时候，除非父加载器找不到相应的类型，否则尽量将这个任务代理给当前加载器的父加载器去做。目的是&lt;strong>避免重复加载Java类型&lt;/strong>。&lt;/p></description></item><item><title>[Java] String、StringBuffer、StringBuilder有什么区别?</title><link>https://yuancode.net/post/java/draftjava_string_stringbuffer_stringbuilder/</link><pubDate>Wed, 03 Aug 2022 00:00:00 +0000</pubDate><guid>https://yuancode.net/post/java/draftjava_string_stringbuffer_stringbuilder/</guid><description>&lt;p>&lt;strong>理解Java的字符串，String、StringBuffer、StringBuilder有什么区别?&lt;/strong>&lt;/p>
&lt;p>&lt;strong>String&lt;/strong>：是Java语言非常基础和重要的类，提供了构造和管理字符串的各种基本逻辑。它是典型的&lt;code>Immutable&lt;/code>类，被声明成为&lt;code>final class&lt;/code>，所有属性也都是&lt;code>final&lt;/code>的。也由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的String对象。由于字符串操作的普遍性，所以相关操作的效率往往对应用性能有明显影响。&lt;/p>
&lt;p>&lt;strong>StringBuffer&lt;/strong>：是为了解决上面提到拼接产生太多中间对象的问题而提供的一个类，可以使用&lt;code>append&lt;/code>或者&lt;code>add&lt;/code>方法，把字符串添加到已有序列的末尾或者指定位置。StringBuffer本质是一个线程安全的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销，所以除非有线程安全的需要，不然还是推荐继续使用StringBuilder。&lt;/p>
&lt;p>&lt;strong>StringBuilder&lt;/strong>：是Java 1.5中新增的，在能力上和StringBuffer没有本质区别，但是它去掉了线程安全部分，有效减小了开销，是绝大部分情况下进行字符串拼接的首选。&lt;/p></description></item><item><title>[Java] Java常见的垃圾收集器有哪些？</title><link>https://yuancode.net/post/java/java_garbage_collector/</link><pubDate>Tue, 02 Aug 2022 00:00:00 +0000</pubDate><guid>https://yuancode.net/post/java/java_garbage_collector/</guid><description>&lt;p>&lt;strong>Java（Oracle JDK）常见的垃圾收集器有哪些？&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>Serial&lt;/li>
&lt;li>ParNew&lt;/li>
&lt;li>CMS&lt;/li>
&lt;li>Parrallel&lt;/li>
&lt;li>G1&lt;/li>
&lt;/ol></description></item><item><title>[Java] 谈谈JVM的内存区域划分，哪些区域可能发生OutOfMemoryError？</title><link>https://yuancode.net/post/java/draftjava_jvm_memory/</link><pubDate>Tue, 02 Aug 2022 00:00:00 +0000</pubDate><guid>https://yuancode.net/post/java/draftjava_jvm_memory/</guid><description>&lt;p>&lt;strong>谈谈JVM的内存区域划分，哪些区域可能发生OutOfMemoryError？&lt;/strong>&lt;/p>
&lt;p>通常可以把JVM内存区域分为下面几个方面，其中，有的区域是以线程为单位，而有的区域则是整个JVM进程唯一的。&lt;/p>
&lt;p>首先，&lt;strong>程序计数器&lt;/strong>（PC, Program Counter Register）。在JVM规范中，每个线程都有自己的程序计数器，并且任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者如果是正在执行本地方法，则是未指定值（undefined）。&lt;/p>
&lt;p>第二，&lt;strong>Java虚拟机栈&lt;/strong>（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。&lt;/p>
&lt;blockquote>
&lt;p>同&lt;code>PC&lt;/code>，在一个时间点，对应的只会有一个活动的栈帧，通常叫做当前帧，方法所在的类叫做当前类。如果在该方法中调用了其他方法，对应新的栈帧会被创建出来，成为新的当前帧，一直到它返回结果或者执行结束。&lt;/p>
&lt;p>栈帧（Stack Frame）存储着局部变量表、操作数（operand）栈、动态链接、方法正常退出或者异常退出的定义等。&lt;/p>
&lt;/blockquote>
&lt;p>第三，&lt;strong>堆&lt;/strong>（Heap），堆是Java内存管理的核心区域，用来放置Java对象实例，几乎所有创建的Java对象实例都是直接被分配在堆上。堆被所有的线程共享，在虚拟机启动时，我们指定的“Xmx”之类的参数就是用来指定最大堆空间等指标。&lt;/p>
&lt;blockquote>
&lt;p>堆是垃圾收集器重点照顾的区域，所以堆内会被不同的垃圾收集器进行进一步的细分，最有名的就是新生代、老年代的划分。&lt;/p>
&lt;/blockquote>
&lt;p>第四，&lt;strong>方法区&lt;/strong>（Method Area）。这也是所有线程共享的一块内存区域，用于存储所谓的元（Meta）数据，例如类结构信息，以及对应的运行时常量池、字段、方法代码等。&lt;/p>
&lt;blockquote>
&lt;p>由于早起的Hotspot JVM实现，很多人习惯于将方法区成为永久代（Permanent Generation）。Oracle JDK 8中将永久代移除，同时增加了元数据区（Metaspace）。&lt;/p>
&lt;/blockquote>
&lt;p>第五，&lt;strong>运行时常量池&lt;/strong>（Run-Time Constant Pool），是方法区的一部分。Java的常量池可以存放各种常量信息，不管是编译器生成的各种字面量，还是需要再运行时决定的符号引用，所以它比一般语言的符号表存储的信息更加宽泛。&lt;/p>
&lt;blockquote>
&lt;p>如果分析过反编译的类文件结构，就能看到版本号、字段、方法、超类、接口等各种信息，还有一项信息就是常量池。&lt;/p>
&lt;/blockquote>
&lt;p>第六，&lt;strong>本地方法栈&lt;/strong>（Native Method Stack）。它和Java虚拟机栈非常相似，支持本地方法的调用，每个线程都会创建一个。在Oracle HotSpot JVM中，本地方法栈和Java虚拟机栈是在同一块儿区域，这完全取决于技术实现的决定，并未在规范中强制。&lt;/p>
&lt;p>&lt;strong>OOM可能发生的区域：&lt;/strong>&lt;/p>
&lt;p>OOM如果通俗点说，就是JVM内存不够用了，Jacadoc中对&lt;code>OutOfMemoryError&lt;/code>的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。&lt;/p>
&lt;p>隐含的意思是，在抛出&lt;code>OutOfMemoryError&lt;/code>之前，通常垃圾收集器会被触发，尽其所能去清理空间。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>垃圾收集器不会被触发的情况：&lt;/strong>&lt;/p>
&lt;p>我们尝试去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可判断出垃圾收集器并不能解决这个问题，所以会直接抛出&lt;code>OutOfMemoryError&lt;/code>。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>堆内存不足是最常见的OOM原因之一，抛出的错误信息是“&lt;code>java.lang.OutOfMemoryError.java jeap space&lt;/code>”，原因较多，例如：内存泄漏；堆的大小不合理（要处理比较可观的数据量，但是没有显示指定JVM堆大小或者指定数值偏小）；JVM处理引用不及时，导致堆积，内存无法释放。&lt;/li>
&lt;li>Java虚拟机栈和本地方法栈也会导致出现OOM问题。比如：无限递归，JVM实际会抛出&lt;code>StackOverFlowError&lt;/code>，如果JVM试图去扩展栈空间失败，则会抛出&lt;code>OutOfMemoryError&lt;/code>。&lt;/li>
&lt;li>老版本Oracle JDK，永久代的大小有限制，并且JVM对其垃圾回收不积极，所以也会出现&lt;code>OutOfMemoryError&lt;/code>，尤其是存在大量动态类型生成的场合。&lt;strong>但是，随着元数据区的引入，方法区内存已经不再那么窘迫。&lt;/strong>&lt;/li>
&lt;li>直接内存不足，也会导致OOM。&lt;/li>
&lt;/ul></description></item><item><title>[Java] Java程序运行在Docker等容器环境有哪些新问题？</title><link>https://yuancode.net/post/java/java_run_in_docker/</link><pubDate>Mon, 01 Aug 2022 00:00:00 +0000</pubDate><guid>https://yuancode.net/post/java/java_run_in_docker/</guid><description>&lt;p>&lt;strong>Java程序运行在Docker等容器环境有哪些新问题？&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Docker的内存、CPU等资源限制是通过CGroup（Control Group）实现的，早期的JDK版本（8u131之前）并不能识别这些限制，进而会导致一些基础问题：
&lt;ul>
&lt;li>如果未配置合适的JVM堆和元数据区、直接内存等参数，Java就有可能试图使用超过容器限制的内存，最终被容器OOM kill，或者自身发生OOM。&lt;/li>
&lt;li>错误判断了可获取的CPU资源，例如，Docker限制了CPU的核数，JVM就可能设置不合适的GC并行线程数等。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>从应用打包、发布等角度触发，JDK自身就比较大，生成的镜像就更为臃肿。当打包镜像较多的时候，存储开销就开始明显了。&lt;/li>
&lt;li>如果考虑到微服务、Serverless等新的架构和场景，Java自身的大小、内存占用、启动速度，都存在一定局限性，因为Java早起的优化大多是针对长时间运行的大兴服务器端应用。&lt;/li>
&lt;/ul></description></item><item><title>[Java] Java有几种文件拷贝方式？</title><link>https://yuancode.net/post/java/java_copy/</link><pubDate>Mon, 01 Aug 2022 00:00:00 +0000</pubDate><guid>https://yuancode.net/post/java/java_copy/</guid><description>&lt;p>&lt;strong>Java有几种文件拷贝方式？哪一种最高效？&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>利用&lt;code>java.io&lt;/code>类库，直接为源文件构建一个&lt;code>FileInputStream&lt;/code>读取，然后再为目标文件构建一个&lt;code>FileOutputStream&lt;/code>，完成写入工作。&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a2f;font-weight:bold">public&lt;/span> &lt;span style="color:#a2f;font-weight:bold">static&lt;/span> &lt;span style="color:#0b0;font-weight:bold">void&lt;/span> &lt;span style="color:#00a000">copyFileByStream&lt;/span>&lt;span style="color:#666">(&lt;/span>File source&lt;span style="color:#666">,&lt;/span> File dest&lt;span style="color:#666">)&lt;/span> &lt;span style="color:#a2f;font-weight:bold">throws&lt;/span> IOException &lt;span style="color:#666">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a2f;font-weight:bold">try&lt;/span>&lt;span style="color:#666">(&lt;/span>InputStream is &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#a2f;font-weight:bold">new&lt;/span> FileInputStream&lt;span style="color:#666">(&lt;/span>source&lt;span style="color:#666">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OutputStream os &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#a2f;font-weight:bold">new&lt;/span> FileOutputStream&lt;span style="color:#666">(&lt;/span>dest&lt;span style="color:#666">);)&lt;/span> &lt;span style="color:#666">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0b0;font-weight:bold">byte&lt;/span>&lt;span style="color:#666">[]&lt;/span> buffer &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#a2f;font-weight:bold">new&lt;/span> &lt;span style="color:#0b0;font-weight:bold">byte&lt;/span>&lt;span style="color:#666">[&lt;/span>1024&lt;span style="color:#666">];&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0b0;font-weight:bold">int&lt;/span> length&lt;span style="color:#666">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a2f;font-weight:bold">while&lt;/span>&lt;span style="color:#666">((&lt;/span>length &lt;span style="color:#666">=&lt;/span> is&lt;span style="color:#666">.&lt;/span>&lt;span style="color:#b44">read&lt;/span>&lt;span style="color:#666">(&lt;/span>buffer&lt;span style="color:#666">))&lt;/span> &lt;span style="color:#666">&amp;gt;&lt;/span> 0&lt;span style="color:#666">)&lt;/span> &lt;span style="color:#666">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os&lt;span style="color:#666">.&lt;/span>&lt;span style="color:#b44">write&lt;/span>&lt;span style="color:#666">(&lt;/span>buffer&lt;span style="color:#666">,&lt;/span> 0&lt;span style="color:#666">,&lt;/span> length&lt;span style="color:#666">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#666">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>利用&lt;code>java.nio&lt;/code>类库提供的&lt;code>transferTo&lt;/code>或&lt;code>transferFrom&lt;/code>方法实现。&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8
&lt;/span>&lt;span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a2f;font-weight:bold">public&lt;/span> &lt;span style="color:#a2f;font-weight:bold">static&lt;/span> &lt;span style="color:#0b0;font-weight:bold">void&lt;/span> &lt;span style="color:#00a000">copyFileByChannel&lt;/span>&lt;span style="color:#666">(&lt;/span>File source&lt;span style="color:#666">,&lt;/span> Filr dest&lt;span style="color:#666">)&lt;/span> &lt;span style="color:#a2f;font-weight:bold">throws&lt;/span> IOException &lt;span style="color:#666">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a2f;font-weight:bold">try&lt;/span>&lt;span style="color:#666">(&lt;/span>FileChannel sourceChannel &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#a2f;font-weight:bold">new&lt;/span> FileInputStream&lt;span style="color:#666">(&lt;/span>source&lt;span style="color:#666">).&lt;/span>&lt;span style="color:#b44">getChannel&lt;/span>&lt;span style="color:#666">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> FileChannel targetChannel &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#a2f;font-weight:bold">new&lt;/span> FileOutputStream&lt;span style="color:#666">(&lt;/span>dest&lt;span style="color:#666">).&lt;/span>&lt;span style="color:#b44">getChannel&lt;/span>&lt;span style="color:#666">();)&lt;/span> &lt;span style="color:#666">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a2f;font-weight:bold">for&lt;/span>&lt;span style="color:#666">(&lt;/span>&lt;span style="color:#0b0;font-weight:bold">long&lt;/span> count &lt;span style="color:#666">=&lt;/span> sourceChannel&lt;span style="color:#666">.&lt;/span>&lt;span style="color:#b44">size&lt;/span>&lt;span style="color:#666">();&lt;/span> count &lt;span style="color:#666">&amp;gt;&lt;/span> 0&lt;span style="color:#666">;&lt;/span> &lt;span style="color:#666">)&lt;/span> &lt;span style="color:#666">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0b0;font-weight:bold">long&lt;/span> transferred &lt;span style="color:#666">=&lt;/span> sourceChannel&lt;span style="color:#666">.&lt;/span>&lt;span style="color:#b44">transferTo&lt;/span>&lt;span style="color:#666">(&lt;/span>sourceChannel&lt;span style="color:#666">.&lt;/span>&lt;span style="color:#b44">position&lt;/span>&lt;span style="color:#666">(),&lt;/span> count&lt;span style="color:#666">,&lt;/span> targetChannel&lt;span style="color:#666">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count &lt;span style="color:#666">-=&lt;/span> transferred&lt;span style="color:#666">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#666">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#666">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>利用Java标准库本身提供的几种&lt;code>File.copy&lt;/code>实现。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>一般来说，NIO的&lt;code>transferTo/transferFrom&lt;/code>的方式更快，因为它&lt;strong>更能利用好现代操作系统的底层机制，避免不必要的拷贝和上下文切换&lt;/strong>。&lt;/p></description></item><item><title>[Java] 谈谈 Java 反射机制，动态代理是基于什么原理?</title><link>https://yuancode.net/post/java/draftjava_reflect/</link><pubDate>Mon, 01 Aug 2022 00:00:00 +0000</pubDate><guid>https://yuancode.net/post/java/draftjava_reflect/</guid><description>&lt;p>&lt;strong>谈谈 Java 反射机制，动态代理是基于什么原理?&lt;/strong>&lt;/p>
&lt;p>反射机制是Java提供的一种基础功能，赋予程序在运行时&lt;strong>自省&lt;/strong>（introspect）的能力。通过反射我们可以直接操作类或者对象，比如获取某个对象的类定义，获取类声明的属性和方法，调用方法或者构造对象，甚至可以运行时修改类定义。&lt;/p>
&lt;p>动态代理是一种&lt;strong>方便运行时动态构建代理、动态处理代理方法调用的机制&lt;/strong>，很多场景都是利用类似机制做到的，比如用来包装RPC调用、面向切面的编程（AOP）。&lt;/p>
&lt;p>实现动态代理的方式很多，比如JDK自身提供的动态代理，就是主要利用了上面提到的反射机制。还有其他的实现方式，比如利用传说中更高性能的字节码操作机制，类似ASM、cglib（基于ASM）、Javassist等。&lt;/p></description></item><item><title>[Java] Exception和Error有什么区别？</title><link>https://yuancode.net/post/java/java_exception_and_error/</link><pubDate>Thu, 28 Jul 2022 00:00:00 +0000</pubDate><guid>https://yuancode.net/post/java/java_exception_and_error/</guid><description>&lt;p>&lt;strong>请对比 Exception 和 Error，另外，运行时异常与一般异常有什么区别?&lt;/strong>&lt;/p>
&lt;p>&lt;code>Exception&lt;/code>和&lt;code>Error&lt;/code>都是继承了&lt;code>Throwable&lt;/code>类，在Java中只有Throwable类型的实例才可以被抛出(throw)或者捕获(catch)，它是异常处理机制的基本组成类型。&lt;/p>
&lt;p>&lt;code>Exception&lt;/code>和&lt;code>Error&lt;/code>体现了Java平台设计者对不同异常情况的分类。&lt;code>Exception&lt;/code>是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。&lt;/p>
&lt;p>&lt;code>Error&lt;/code>是指在正常情况下，不大可能出现的情况，绝大部分的Error都会导致程序（比如JVM自身）处于非正常的、不可恢复状态。既然是非正常情况，所以不便于也不需要捕获，常见的比如&lt;code>OutOfMemoryError&lt;/code>之类，都是&lt;code>Error&lt;/code>的子类。&lt;strong>注意：&lt;code>Error&lt;/code>是&lt;code>Throwable&lt;/code>不是&lt;code>Exception&lt;/code>虽然它不可查。&lt;/strong>&lt;/p>
&lt;p>&lt;code>Exception&lt;/code>又分为&lt;strong>受检查&lt;/strong>(checked)异常和&lt;strong>未检查&lt;/strong>(unchecked)异常，&lt;strong>可检查&lt;/strong>异常在源代码里必须显示地进行捕获处理，这是编译期检查的一部分。&lt;/p>
&lt;p>不检查异常就是所谓的&lt;strong>运行时异常&lt;/strong>，类似&lt;code>NullPointerException&lt;/code>（空指针）、&lt;code>ArrayIndexOutOfBoundsException&lt;/code>（下标越界）之类，通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译期强制要求。&lt;/p></description></item><item><title>[Java] 强引用、软引用、弱引用、虚引用</title><link>https://yuancode.net/post/java/java_reference/</link><pubDate>Thu, 28 Jul 2022 00:00:00 +0000</pubDate><guid>https://yuancode.net/post/java/java_reference/</guid><description>&lt;p>在&lt;code>JDK 1.2&lt;/code>版本之后，Java对引用的概念进行了扩充，将引用分为强引用（Strongly Re-ference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。&lt;/p>
&lt;p>&lt;strong>强引用、软引用、弱引用、幻象引用有什么区别?具体使用场景是
什么?&lt;/strong>&lt;/p></description></item><item><title>[Java] 谈谈final、finally、finalize有什么不同？</title><link>https://yuancode.net/post/java/java_final_finally_finalize/</link><pubDate>Thu, 28 Jul 2022 00:00:00 +0000</pubDate><guid>https://yuancode.net/post/java/java_final_finally_finalize/</guid><description>&lt;p>&lt;strong>谈谈&lt;code>final&lt;/code>、&lt;code>finally&lt;/code>、&lt;code>finalize&lt;/code>有什么不同？&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>final&lt;/code>：可以用来修饰类、方法、变量，分别有不同的意义：
&lt;ul>
&lt;li>类（&lt;code>class&lt;/code>）：不可以继承扩展&lt;/li>
&lt;li>方法：不可以重写（override）&lt;/li>
&lt;li>变量：不可以修改&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>finally&lt;/code>：Java保证重点代码一定会被执行的一种机制。可以使用&lt;code>try-finally&lt;/code>或者&lt;code>try-catch-finally&lt;/code>来进行类似关闭JDBC连接、保证unlock锁等动作。&lt;/li>
&lt;li>&lt;code>finalize&lt;/code>：是基础类&lt;code>java.lang.Object&lt;/code>的一个方法，它设计目的是保证对象在被垃圾收集前完成特定资源的回收。&lt;code>finalize&lt;/code>机制现在已经不推荐使用，并且在JDK 9开始被标记为&lt;code>deprecated&lt;/code>。&lt;/li>
&lt;/ul></description></item><item><title>[Mysql] 谈谈Mysql支持的事务隔离级别，以及悲观锁和乐观锁。</title><link>https://yuancode.net/post/draftmysql_isolation_level_and_lock/</link><pubDate>Wed, 20 Jul 2022 00:00:00 +0000</pubDate><guid>https://yuancode.net/post/draftmysql_isolation_level_and_lock/</guid><description>&lt;p>谈谈 MySQL 支持的事务隔离级别，以及悲观锁和乐观锁的原理和应用场景?&lt;/p>
&lt;p>隔离级别（Isolation Level），就是在数据库事务中，为保证并发数据读写的正确性而提出的定义，它并不是Mysql专有的概念。&lt;strong>事务的隔离级别受到数据库的限制，不同的数据库支持的隔离级别不一定相同&lt;/strong>&lt;/p></description></item><item><title>[Java] Java 提供了哪些 IO 方式? NIO 如何实现多路复用?</title><link>https://yuancode.net/post/java/draftjava_io_nio/</link><pubDate>Sun, 17 Jul 2022 00:00:00 +0000</pubDate><guid>https://yuancode.net/post/java/draftjava_io_nio/</guid><description>&lt;p>Java 提供了哪些 IO 方式? NIO 如何实现多路复用?&lt;/p>
&lt;img src="https://imagebed-1253103817.cos.ap-beijing.myqcloud.com/images/202207271750077.png" style="zoom:50%;" />
&lt;ol>
&lt;li>
&lt;p>java.io (Blocking I/O)&lt;/p>
&lt;p>BIO属于同步阻塞IO模型。应用程序发起read调用后，会一直阻塞，直到内核把数据拷贝到用户空间。也就是说在读、写动作完成之前，线程会一直阻塞在那里。&lt;/p>
&lt;p>好处是代码比较简单直观，缺点则是IO效率和扩展性存在局限性，容易成为应用性能的瓶颈。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>java.nio (Java1.4，Non-blocking/New I/O)&lt;/p>
&lt;p>提供了&lt;code>Channel&lt;/code>、&lt;code>Selector&lt;/code>、&lt;code>Buffer&lt;/code>等抽象。&lt;/p>
&lt;p>可以构建多路复用的、同步非阻塞IO程序。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>java.nio2(Java7 异步非阻塞IO方式)&lt;/p>
&lt;p>java.nio的改进版，异步IO模型，也被称为AIO(Asynchronous IO)。&lt;/p>
&lt;p>异步IO操作基于时间和回调机制，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作。&lt;/p>
&lt;/li>
&lt;/ol></description></item><item><title>[Java] 对比 Hashtable、HashMap、TreeMap 有什么不同?</title><link>https://yuancode.net/post/java/draftjava_hashtable_hashmap_treemap/</link><pubDate>Sun, 17 Jul 2022 00:00:00 +0000</pubDate><guid>https://yuancode.net/post/java/draftjava_hashtable_hashmap_treemap/</guid><description>&lt;p>&lt;strong>对比 &lt;code>Hashtable&lt;/code>、&lt;code>HashMap&lt;/code>、&lt;code>TreeMap&lt;/code> 有什么不同?谈谈你对 HashMap 的掌握。&lt;/strong>&lt;/p>
&lt;p>&lt;code>Hashtable&lt;/code>、&lt;code>HashMap&lt;/code>、&lt;code>TreeMap&lt;/code>都是最常见的一些Map实现，是以&lt;em>键值对&lt;/em>的形式存储和操作数据的容器类型。&lt;/p>
&lt;p>&lt;code>Hashtable&lt;/code>是早期Java类库提供的哈希表实现，本身是同步的，不支持&lt;code>null&lt;/code>的&lt;code>key&lt;/code>和&lt;code>value&lt;/code>。&lt;/p>
&lt;p>&lt;code>HashMap&lt;/code>是应用更加广泛的哈希表实现，基于哈希表的&lt;code>Map&lt;/code>接口实现，行为上大致与&lt;code>HashTable&lt;/code>一致，是非线程安全的，可以存储&lt;code>null&lt;/code>的&lt;code>key&lt;/code>和&lt;code>value&lt;/code>。&lt;/p>
&lt;p>&lt;code>TreeMap&lt;/code>是基于红黑树的一种提供顺序访问的Map，和&lt;code>HashMap&lt;/code>不同，它的&lt;code>get&lt;/code>、&lt;code>put&lt;/code>、&lt;code>remove&lt;/code>之类操作的时间复杂度都是&lt;code>O(logn)&lt;/code>，可以通过手写&lt;code>Comparator&lt;/code>函数来决定键的具体顺序。&lt;/p></description></item><item><title>[Java] 谈谈你对Java平台的理解？</title><link>https://yuancode.net/post/java/java_about_java/</link><pubDate>Sun, 17 Jul 2022 00:00:00 +0000</pubDate><guid>https://yuancode.net/post/java/java_about_java/</guid><description>&lt;p>&lt;strong>谈谈你对 Java 平台的理解?“Java 是解释执行”，这句话正确吗?&lt;/strong>&lt;/p>
&lt;p>Java本身是一种面向对象（继承、封装、多态）的语言，最显著的特性有两个方面：一是“编写一次，处处运行”(Write once, run anywhere)（JVM运行&lt;code>.class&lt;/code>文件），能够非常容易地获得跨平台能力；二是垃圾收集(GC, Garbage Collection)，Java通过垃圾收集器回收分配内存，大部分情况下，程序员不需要自己操心内存的分配和回收。&lt;/p>
&lt;p>“Java 是解释执行”这句话并不准确，Java源代码经过javac编译成.class字节码文件，.class字节码文件经过JVM解释或编译运行。JDK中提供了JIT(Just-In-Time)编译器，也就是通常所说的动态编译器，JIT能够在运行时将热点代码编译成与本地平台相关的机器码，这种情况下部分热点代码就属于==编译执行==，而不是解释执行。同时，Java9提供了AOT编译器，可以直接将所有代码编译成机器码执行。&lt;/p></description></item><item><title>[Java]Vector、ArrayList、LinkedList的区别</title><link>https://yuancode.net/post/java/draftjava_vector_arraylist_linkedlist/</link><pubDate>Sun, 17 Jul 2022 00:00:00 +0000</pubDate><guid>https://yuancode.net/post/java/draftjava_vector_arraylist_linkedlist/</guid><description>&lt;p>对比 Vector、ArrayList、LinkedList 有何区别?&lt;/p>
&lt;p>Vector：线程安全的动态数组，扩容时增加1倍。&lt;/p>
&lt;p>ArrayList：动态数组，扩容时增加50%。&lt;/p>
&lt;p>LinkedList：双向链表，不需要像上面两种一样调整容量。&lt;/p>
&lt;p>Vector和ArrayList内部元素以数组形式存储，适合随机访问的场合。&lt;/p>
&lt;p>LinkedList进行节点的插入、删除时比较高效。&lt;/p></description></item><item><title>[Java基础]int和Integer的区别</title><link>https://yuancode.net/post/java/java_int_and_integer/</link><pubDate>Sun, 17 Jul 2022 00:00:00 +0000</pubDate><guid>https://yuancode.net/post/java/java_int_and_integer/</guid><description>&lt;p>&lt;strong>int和Integer有什么区别？谈谈Integer的值缓存范围。&lt;/strong>&lt;/p>
&lt;p>Integer是int对应的包装类，它有一个int类型的字段存储数据，并且提供了基本操作，比如数学运算、int和字符串之间转换等。在&lt;code>Java5&lt;/code>中，引入了自动装箱和自动拆箱功能&lt;sup>1&lt;/sup>（boxing/unboxing），Java可以根据上下文，自动进行转换，很大程度上简化了相关编程。&lt;/p>
&lt;p>int也就是Java中的整形数字，是Java的8个原始数据类型&lt;sup>2&lt;/sup>,&lt;font color="red">Java虽然号称一切都是对象，但是原始数据类型是例外&lt;/font>。&lt;/p>
&lt;p>关于Integer的值缓存，涉及Java5中的另一个改进。构建Integer对象的传统方式是直接调用构造器new一个对象。但是大部分数据操作都是集中在有限的、较小的数值范围，因此在&lt;code>Java5&lt;/code>中新增了静态工厂方法&lt;sup>3&lt;/sup>valueOf，在调用它的时候会利用一个缓存机制，带来明显的性能改进。值默认缓存范围是*-128到127之间*(2^8)。&lt;/p></description></item></channel></rss>