<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>reflect on 元代码</title><link>https://yuancode.net/tags/reflect/</link><description>Recent content in reflect on 元代码</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 01 Aug 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://yuancode.net/tags/reflect/index.xml" rel="self" type="application/rss+xml"/><item><title>[Java] 谈谈 Java 反射机制，动态代理是基于什么原理?</title><link>https://yuancode.net/post/java_reflect/</link><pubDate>Mon, 01 Aug 2022 00:00:00 +0000</pubDate><guid>https://yuancode.net/post/java_reflect/</guid><description>&lt;p>&lt;strong>谈谈 Java 反射机制，动态代理是基于什么原理?&lt;/strong>&lt;/p>
&lt;p>反射机制是Java提供的一种基础功能，赋予程序在运行时&lt;strong>自省&lt;/strong>（introspect）的能力。通过反射我们可以直接操作类或者对象，比如获取某个对象的类定义，获取类声明的属性和方法，调用方法或者构造对象，甚至可以运行时修改类定义。&lt;/p>
&lt;p>动态代理是一种&lt;strong>方便运行时动态构建代理、动态处理代理方法调用的机制&lt;/strong>，很多场景都是利用类似机制做到的，比如用来包装RPC调用、面向切面的编程（AOP）。&lt;/p>
&lt;p>实现动态代理的方式很多，比如JDK自身提供的动态代理，就是主要利用了上面提到的反射机制。还有其他的实现方式，比如利用传说中更高性能的字节码操作机制，类似ASM、cglib（基于ASM）、Javassist等。&lt;/p></description></item></channel></rss>