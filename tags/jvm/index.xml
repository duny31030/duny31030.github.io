<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>JVM on 元代码</title><link>https://yuancode.net/tags/jvm/</link><description>Recent content in JVM on 元代码</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sun, 07 Aug 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://yuancode.net/tags/jvm/index.xml" rel="self" type="application/rss+xml"/><item><title>[JVM] Java的类加载机制</title><link>https://yuancode.net/post/java/jvm/draftjvm_classloader/</link><pubDate>Sun, 07 Aug 2022 00:00:00 +0000</pubDate><guid>https://yuancode.net/post/java/jvm/draftjvm_classloader/</guid><description>&lt;p>&lt;strong>Java的类加载机制&lt;/strong>&lt;/p>
&lt;p>一般，Java的类加载过程分为三个主要步骤：加载、连接、初始化。&lt;/p>
&lt;ol>
&lt;li>加载（Loading），将字节码数据从不同的数据源读取到JVM中，并映射为JVM认可的数据结构（Class对象），数据源可能是jar文件、class文件甚至网络数据源。如果输入数据不是ClassFile结构，则会抛出&lt;code>ClassFromatError&lt;/code>。
&lt;ul>
&lt;li>加载阶段是用户参与的阶段，我们可以自定义类加载器，实现自己的类加载过程。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>连接（Linking），是核心步骤，把原始的类定义信息平滑的转化到JVM运行的过程中。可以进一步分为三个步骤：
&lt;ol>
&lt;li>验证（Verification），虚拟机安全的重要保障，验证字节信息是否符合Java虚拟机规范，否则被认为是&lt;code>VerifyError&lt;/code>，防止恶意信息或不合规的信息危害JVM的运行。&lt;/li>
&lt;li>准备（Preparation），创建类或接口中的静态变量，并初始化静态变量的初始值。==侧重点在于分配所需的内存空间，不会执行进一步的JVM指令。==&lt;/li>
&lt;li>解析（Resolution），将常量池中的符号引用（symbolic reference）替换为直接引用。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>初始化（initialization），真正去执行类初始化的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态初始化块内的逻辑，编译器在编译阶段就会把这部分逻辑整理好，父类型的初始化逻辑优先于当前类型的逻辑。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>关于双亲委派模型：&lt;/strong>&lt;/p>
&lt;p>简单说就是当类加载器（Class-Loader）试图加载某个类型的时候，除非父加载器找不到相应的类型，否则尽量将这个任务代理给当前加载器的父加载器去做。目的是&lt;strong>避免重复加载Java类型&lt;/strong>。&lt;/p></description></item><item><title>[Java] Java常见的垃圾收集器有哪些？</title><link>https://yuancode.net/post/java/java_garbage_collector/</link><pubDate>Tue, 02 Aug 2022 00:00:00 +0000</pubDate><guid>https://yuancode.net/post/java/java_garbage_collector/</guid><description>&lt;p>&lt;strong>Java（Oracle JDK）常见的垃圾收集器有哪些？&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>Serial&lt;/li>
&lt;li>ParNew&lt;/li>
&lt;li>CMS&lt;/li>
&lt;li>Parrallel&lt;/li>
&lt;li>G1&lt;/li>
&lt;/ol></description></item><item><title>[Java] 谈谈JVM的内存区域划分，哪些区域可能发生OutOfMemoryError？</title><link>https://yuancode.net/post/java/draftjava_jvm_memory/</link><pubDate>Tue, 02 Aug 2022 00:00:00 +0000</pubDate><guid>https://yuancode.net/post/java/draftjava_jvm_memory/</guid><description>&lt;p>&lt;strong>谈谈JVM的内存区域划分，哪些区域可能发生OutOfMemoryError？&lt;/strong>&lt;/p>
&lt;p>通常可以把JVM内存区域分为下面几个方面，其中，有的区域是以线程为单位，而有的区域则是整个JVM进程唯一的。&lt;/p>
&lt;p>首先，&lt;strong>程序计数器&lt;/strong>（PC, Program Counter Register）。在JVM规范中，每个线程都有自己的程序计数器，并且任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者如果是正在执行本地方法，则是未指定值（undefined）。&lt;/p>
&lt;p>第二，&lt;strong>Java虚拟机栈&lt;/strong>（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。&lt;/p>
&lt;blockquote>
&lt;p>同&lt;code>PC&lt;/code>，在一个时间点，对应的只会有一个活动的栈帧，通常叫做当前帧，方法所在的类叫做当前类。如果在该方法中调用了其他方法，对应新的栈帧会被创建出来，成为新的当前帧，一直到它返回结果或者执行结束。&lt;/p>
&lt;p>栈帧（Stack Frame）存储着局部变量表、操作数（operand）栈、动态链接、方法正常退出或者异常退出的定义等。&lt;/p>
&lt;/blockquote>
&lt;p>第三，&lt;strong>堆&lt;/strong>（Heap），堆是Java内存管理的核心区域，用来放置Java对象实例，几乎所有创建的Java对象实例都是直接被分配在堆上。堆被所有的线程共享，在虚拟机启动时，我们指定的“Xmx”之类的参数就是用来指定最大堆空间等指标。&lt;/p>
&lt;blockquote>
&lt;p>堆是垃圾收集器重点照顾的区域，所以堆内会被不同的垃圾收集器进行进一步的细分，最有名的就是新生代、老年代的划分。&lt;/p>
&lt;/blockquote>
&lt;p>第四，&lt;strong>方法区&lt;/strong>（Method Area）。这也是所有线程共享的一块内存区域，用于存储所谓的元（Meta）数据，例如类结构信息，以及对应的运行时常量池、字段、方法代码等。&lt;/p>
&lt;blockquote>
&lt;p>由于早起的Hotspot JVM实现，很多人习惯于将方法区成为永久代（Permanent Generation）。Oracle JDK 8中将永久代移除，同时增加了元数据区（Metaspace）。&lt;/p>
&lt;/blockquote>
&lt;p>第五，&lt;strong>运行时常量池&lt;/strong>（Run-Time Constant Pool），是方法区的一部分。Java的常量池可以存放各种常量信息，不管是编译器生成的各种字面量，还是需要再运行时决定的符号引用，所以它比一般语言的符号表存储的信息更加宽泛。&lt;/p>
&lt;blockquote>
&lt;p>如果分析过反编译的类文件结构，就能看到版本号、字段、方法、超类、接口等各种信息，还有一项信息就是常量池。&lt;/p>
&lt;/blockquote>
&lt;p>第六，&lt;strong>本地方法栈&lt;/strong>（Native Method Stack）。它和Java虚拟机栈非常相似，支持本地方法的调用，每个线程都会创建一个。在Oracle HotSpot JVM中，本地方法栈和Java虚拟机栈是在同一块儿区域，这完全取决于技术实现的决定，并未在规范中强制。&lt;/p>
&lt;p>&lt;strong>OOM可能发生的区域：&lt;/strong>&lt;/p>
&lt;p>OOM如果通俗点说，就是JVM内存不够用了，Jacadoc中对&lt;code>OutOfMemoryError&lt;/code>的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。&lt;/p>
&lt;p>隐含的意思是，在抛出&lt;code>OutOfMemoryError&lt;/code>之前，通常垃圾收集器会被触发，尽其所能去清理空间。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>垃圾收集器不会被触发的情况：&lt;/strong>&lt;/p>
&lt;p>我们尝试去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可判断出垃圾收集器并不能解决这个问题，所以会直接抛出&lt;code>OutOfMemoryError&lt;/code>。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>堆内存不足是最常见的OOM原因之一，抛出的错误信息是“&lt;code>java.lang.OutOfMemoryError.java jeap space&lt;/code>”，原因较多，例如：内存泄漏；堆的大小不合理（要处理比较可观的数据量，但是没有显示指定JVM堆大小或者指定数值偏小）；JVM处理引用不及时，导致堆积，内存无法释放。&lt;/li>
&lt;li>Java虚拟机栈和本地方法栈也会导致出现OOM问题。比如：无限递归，JVM实际会抛出&lt;code>StackOverFlowError&lt;/code>，如果JVM试图去扩展栈空间失败，则会抛出&lt;code>OutOfMemoryError&lt;/code>。&lt;/li>
&lt;li>老版本Oracle JDK，永久代的大小有限制，并且JVM对其垃圾回收不积极，所以也会出现&lt;code>OutOfMemoryError&lt;/code>，尤其是存在大量动态类型生成的场合。&lt;strong>但是，随着元数据区的引入，方法区内存已经不再那么窘迫。&lt;/strong>&lt;/li>
&lt;li>直接内存不足，也会导致OOM。&lt;/li>
&lt;/ul></description></item><item><title>[Java] 强引用、软引用、弱引用、虚引用</title><link>https://yuancode.net/post/java/java_reference/</link><pubDate>Thu, 28 Jul 2022 00:00:00 +0000</pubDate><guid>https://yuancode.net/post/java/java_reference/</guid><description>&lt;p>在&lt;code>JDK 1.2&lt;/code>版本之后，Java对引用的概念进行了扩充，将引用分为强引用（Strongly Re-ference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。&lt;/p>
&lt;p>&lt;strong>强引用、软引用、弱引用、幻象引用有什么区别?具体使用场景是
什么?&lt;/strong>&lt;/p></description></item></channel></rss>