<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>💻元代码</title>
    <link>https://yuancode.net/</link>
    <description>Recent content on 💻元代码</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>2022 ♾️ 杜宁元的Blog</copyright>
    <lastBuildDate>Sun, 07 Aug 2022 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://yuancode.net/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>[JVM] Java的类加载机制</title>
        <link>https://yuancode.net/posts/java/jvm/draftjvm_classloader/</link>
        <pubDate>Sun, 07 Aug 2022 00:00:00 +0000</pubDate>
        
        <guid>https://yuancode.net/posts/java/jvm/draftjvm_classloader/</guid>
        <description>💻元代码 https://yuancode.net/posts/java/jvm/draftjvm_classloader/ -&lt;p&gt;&lt;strong&gt;Java的类加载机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般，Java的类加载过程分为三个主要步骤：加载、连接、初始化。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;加载（Loading），将字节码数据从不同的数据源读取到JVM中，并映射为JVM认可的数据结构（Class对象），数据源可能是jar文件、class文件甚至网络数据源。如果输入数据不是ClassFile结构，则会抛出&lt;code&gt;ClassFromatError&lt;/code&gt;。
&lt;ul&gt;
&lt;li&gt;加载阶段是用户参与的阶段，我们可以自定义类加载器，实现自己的类加载过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;连接（Linking），是核心步骤，把原始的类定义信息平滑的转化到JVM运行的过程中。可以进一步分为三个步骤：
&lt;ol&gt;
&lt;li&gt;验证（Verification），虚拟机安全的重要保障，验证字节信息是否符合Java虚拟机规范，否则被认为是&lt;code&gt;VerifyError&lt;/code&gt;，防止恶意信息或不合规的信息危害JVM的运行。&lt;/li&gt;
&lt;li&gt;准备（Preparation），创建类或接口中的静态变量，并初始化静态变量的初始值。==侧重点在于分配所需的内存空间，不会执行进一步的JVM指令。==&lt;/li&gt;
&lt;li&gt;解析（Resolution），将常量池中的符号引用（symbolic reference）替换为直接引用。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;初始化（initialization），真正去执行类初始化的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态初始化块内的逻辑，编译器在编译阶段就会把这部分逻辑整理好，父类型的初始化逻辑优先于当前类型的逻辑。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;关于双亲委派模型：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单说就是当类加载器（Class-Loader）试图加载某个类型的时候，除非父加载器找不到相应的类型，否则尽量将这个任务代理给当前加载器的父加载器去做。目的是&lt;strong&gt;避免重复加载Java类型&lt;/strong&gt;。&lt;/p&gt;- https://yuancode.net/posts/java/jvm/draftjvm_classloader/ - 2022 ♾️ 杜宁元的Blog</description>
        </item>
    
    
    
        <item>
        <title>[Spring] IoC和AOP</title>
        <link>https://yuancode.net/posts/java/spring/spring_ioc_aop/</link>
        <pubDate>Thu, 04 Aug 2022 00:00:00 +0000</pubDate>
        
        <guid>https://yuancode.net/posts/java/spring/spring_ioc_aop/</guid>
        <description>💻元代码 https://yuancode.net/posts/java/spring/spring_ioc_aop/ -&lt;blockquote&gt;
&lt;p&gt;Spring的AOP和IOC都是为了解决系统代码耦合度过高的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;IoC是什么？有什么好处？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;IoC（Inverse of Control，控制反转）是一种&lt;strong&gt;设计思想&lt;/strong&gt;，即将程序中需要手动创建的对象的控制权交由框架来进行管理，用户不需要关心具体的创建细节和依赖关系，只需要提供部分配置信息即可。过程如下：&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;如下图所示，IoC是&lt;strong&gt;依赖倒置原则&lt;/strong&gt;的一种实现思路，而实现IoC的方法可以采用&lt;strong&gt;依赖注入&lt;/strong&gt;（DI），IoC容器就是实现了IoC的一种容器。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;blockquote&gt;
&lt;p&gt;DI：依赖注入是指将类所依赖的其他类的对象通过构造/Setter方法注入进来，而不是在当前类的内部new一个所依赖的对象。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;依赖：bean对象的创建依赖于容器。&lt;/li&gt;
&lt;li&gt;注入：bean对象中的所有属性，由容器来注入。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如：&lt;strong&gt;汽车&lt;/strong&gt;&amp;lt;&amp;ndash;依赖&amp;ndash;&lt;strong&gt;车身&lt;/strong&gt;&amp;lt;&amp;ndash;依赖&amp;ndash;&lt;strong&gt;底盘&lt;/strong&gt;&amp;lt;&amp;ndash;依赖&amp;ndash;&lt;strong&gt;轮胎&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;采用DI的方式，当我们轮胎发生变化时，只需要修改轮胎类即可，不影响其他类的代码编写。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;/blockquote&gt;
&lt;p&gt;上图中，初始化一辆车需要很多new代码，而IoC容器则可以帮助我们省去这个麻烦的过程，使得我们创建实例时不需要了解他的细节，&lt;strong&gt;只需要提供一定的XML或注解姐配置&lt;/strong&gt;即可。&lt;/p&gt;
&lt;p&gt;Spring中的IoC的实现原理是&lt;strong&gt;工厂模式&lt;/strong&gt;加&lt;strong&gt;反射机制&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;好处：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IOC容器可以自动完成对象的初始化，用户不需要编写大量复杂的初始化代码，只需要维护/提供一部分必要的配置信息即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户在创建实例的时候可以不需要了解各个对象之间的依赖关系和具体的细节。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;strong&gt;AOP是什么？有什么好处？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;AOP（Aspect-Oriented Programming，面向切面编程）能够将那些与业务无关，&lt;strong&gt;却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制、统一全局异常处理等）封装起来，便于减少系统的重复代码，降低模块间的耦合度&lt;/strong&gt;，并有利于未来的可扩展性和可维护性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;比如：在编写业务逻辑代码的时候，我们习惯性的都要写：日志记录，事务控制，以及权限控制等，每个子模块都要写这些代码，代码明显存在重复。这时候，我们运用面向切面的编程思想，采用横切技术，&lt;strong&gt;将代码中重复的部分，不影响业务逻辑的部分抽取出来，放在某个地方进行集中式的管理，调用&lt;/strong&gt;。形成日志切面，事务控制切面。这样，我们就只需要关心业务的逻辑处理，既提高了工作的效率，又使得代码变得简洁优雅。它是面向对象编程思想的一种扩展。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Spring AOP的底层实现原理主要是&lt;strong&gt;代理模式&lt;/strong&gt;，对原来目标对象创建代理对象，并且在不改变原来对象代码的情况下，通过代理对象，调用增强功能的方法，对原有业务进行增强。&lt;/p&gt;
&lt;p&gt;AOP的代理分为&lt;strong&gt;动态代理&lt;/strong&gt;和&lt;strong&gt;静态代理&lt;/strong&gt;，Spring AOP中使用的是&lt;strong&gt;动态代理&lt;/strong&gt;实现的AOP，AspectJ则是使用&lt;strong&gt;静态代理&lt;/strong&gt;实现的AOP。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当Bean实现接口时，使用&lt;strong&gt;JDK动态代理&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;1&lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;li&gt;当Bean没有实现接口时，使用&lt;strong&gt;CGLib动态代理&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;1&lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;[1] JDK动态代理、CGLib动态代理：&lt;/p&gt;- https://yuancode.net/posts/java/spring/spring_ioc_aop/ - 2022 ♾️ 杜宁元的Blog</description>
        </item>
    
    
    
        <item>
        <title>[Java] Java常见的垃圾收集器有哪些？</title>
        <link>https://yuancode.net/posts/java/java_garbage_collector/</link>
        <pubDate>Tue, 02 Aug 2022 00:00:00 +0000</pubDate>
        
        <guid>https://yuancode.net/posts/java/java_garbage_collector/</guid>
        <description>💻元代码 https://yuancode.net/posts/java/java_garbage_collector/ -&lt;p&gt;&lt;strong&gt;Java（Oracle JDK）常见的垃圾收集器有哪些？&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Serial&lt;/li&gt;
&lt;li&gt;ParNew&lt;/li&gt;
&lt;li&gt;CMS&lt;/li&gt;
&lt;li&gt;Parrallel&lt;/li&gt;
&lt;li&gt;G1&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;Serial GC：
&lt;ol&gt;
&lt;li&gt;最古老的GC；&lt;/li&gt;
&lt;li&gt;单线程工作；&lt;/li&gt;
&lt;li&gt;会进入“Stop-The-World”状态；&lt;/li&gt;
&lt;li&gt;Client模式下JVM的默认选项；&lt;/li&gt;
&lt;li&gt;老年代实现单独称为Serial Old；&lt;/li&gt;
&lt;li&gt;采用标记-整理（Mark-Compact）算法。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;ParNew GC：
&lt;ol&gt;
&lt;li&gt;新生代GC实现；&lt;/li&gt;
&lt;li&gt;Serial GC的多线程版本；&lt;/li&gt;
&lt;li&gt;配合老年代的CMS GC工作。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;CMS（Concurrent Mark Sweep）GC：
&lt;ol&gt;
&lt;li&gt;基于标记-清除（Mark-Sweep）算法；&lt;/li&gt;
&lt;li&gt;设计目标为尽量减少停顿时间；&lt;/li&gt;
&lt;li&gt;算法原因，存在着&lt;strong&gt;内存碎片化&lt;/strong&gt;的问题；&lt;/li&gt;
&lt;li&gt;长时间运行会发生&lt;code&gt;full GC&lt;/code&gt;，出现停顿；&lt;/li&gt;
&lt;li&gt;由于并发（Concurrent），会占用更多CPU资源，并和用户线程争抢。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Parrallel GC：
&lt;ol&gt;
&lt;li&gt;早期JDK 8等版本中，是Server模式JVM的默认GC选择；&lt;/li&gt;
&lt;li&gt;吞吐量优先的GC；&lt;/li&gt;
&lt;li&gt;特点：新生代和老年代GC都是并行进行的。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;G1 GC：
&lt;ol&gt;
&lt;li&gt;兼顾吞吐量和停顿时间的GC实现，Oracle JDK 9以后默认GC选项；&lt;/li&gt;
&lt;li&gt;相比CMS，最差情况停顿时间要好很多；&lt;/li&gt;
&lt;li&gt;仍然存在年代概念，内存并非条带式划分，是类似棋盘的一个个region；&lt;/li&gt;
&lt;li&gt;Region之间是复制算法，整体可看作标记-整理（Mark-Compact）算法，可以有效避免内存碎片，Java堆非常大的时候，优势更明显；&lt;/li&gt;
&lt;li&gt;G1的吞吐量和停顿表现都非常不错，并仍在完善，CMS已经在JDK 9中被标记为废弃（deprecated）。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;strong&gt;扩展：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;垃圾收集的原理和基础概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;自动垃圾收集的前提是清楚哪些内存可以被释放。主要是两个方面，最主要部分是对象实例，都是存储在堆上的；还有方法区中的元数据等信息，例如类型不再使用，卸载该Java类。&lt;/p&gt;
&lt;p&gt;对于对象实例收集，主要是两种基本算法，引用计数和可达性分析。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;引用计数算法，就是为对象添加一个引用计数，用于记录对象被引用的情况，如果计数为0，即表示对象可回收。
&lt;ul&gt;
&lt;li&gt;引用计数算法很难处理&lt;strong&gt;循环引用&lt;/strong&gt;问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可达性分析算法，将对象及其引用关系看作一个图，选定活动的对象作为GC Roots，然后跟踪引用链条，如果一个对象和GC Roots之间不可达，也就是不存在引用链条，那么即可认为是可回收对象。
&lt;ul&gt;
&lt;li&gt;虚拟机栈和本地方法栈中正在引用的对象、静态属性引用的对象和常量 —— GC Roots。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常见的垃圾收集算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;复制（Copying）算法：将可用内存分为两块，每次只使用其中的一块。当这一块内存用完了，就将存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。可以避免内存碎片化，但是会有大量内存间复制的开销，空间浪费也较多。&lt;/li&gt;
&lt;li&gt;标记-清除（Mark-Sweep）算法：首先进行标记工作，标记出所有要回收的对象，然后进行清除。存在不可避免的碎片化问题，不适合特别大的堆；一旦出现Full GC，暂停时间也过久，可能无法接受。&lt;/li&gt;
&lt;li&gt;标记-整理（Mark-Compact）算法：类似标记-清除，但为避免内存碎片化，会在清理过程中将对象移动，确保移动后的对象占用连续的内存空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;垃圾收集过程的理解&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;JVM区域总体分两类，heap区和非heap区。heap区又分：Eden Space（伊甸园）、Survivor  Space(幸存者区)、Tenured Gen（老年代-养老区）。 非heap区又分：Code Cache(代码缓存区)、Perm  Gen（永久代）、Jvm Stack(java虚拟机栈)、Local Method Statck(本地方法栈)。&lt;/p&gt;
&lt;p&gt;Minor GC：新生代GC;&lt;/p&gt;
&lt;p&gt;Major GC：老年代GC;出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上；&lt;/p&gt;
&lt;p&gt;Full GC：将整个堆进行清理；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、一个人（对象）出来（new 出来）后会在Eden  Space（伊甸园）无忧无虑的生活，直到GC到来打破了他们平静的生活。GC会逐一问清楚每个对象的情况，有没有钱（此对象的引用）啊，因为GC想赚钱呀，有钱的才可以敲诈嘛。然后富人就会进入Survivor Space（幸存者区），穷人的就直接kill掉。&lt;/p&gt;
&lt;p&gt;2、并不是进入Survivor  Space（幸存者区）后就保证人身是安全的，但至少可以活段时间。GC会定期（可以自定义）会对这些人进行敲诈，亿万富翁每次都给钱，GC很满意，就让其进入了Genured Gen(养老区)。万元户经不住几次敲诈就没钱了，GC看没有啥价值啦，就直接kill掉了。&lt;/p&gt;
&lt;p&gt;3、进入到养老区的人基本就可以保证人身安全啦，但是亿万富豪有的也会挥霍成穷光蛋，只要钱没了，GC还是kill掉。&lt;/p&gt;- https://yuancode.net/posts/java/java_garbage_collector/ - 2022 ♾️ 杜宁元的Blog</description>
        </item>
    
    
    
        <item>
        <title>[Java] Java有几种文件拷贝方式？</title>
        <link>https://yuancode.net/posts/java/java_copy/</link>
        <pubDate>Mon, 01 Aug 2022 00:00:00 +0000</pubDate>
        
        <guid>https://yuancode.net/posts/java/java_copy/</guid>
        <description>💻元代码 https://yuancode.net/posts/java/java_copy/ -&lt;p&gt;&lt;strong&gt;Java有几种文件拷贝方式？哪一种最高效？&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;利用&lt;code&gt;java.io&lt;/code&gt;类库，直接为源文件构建一个&lt;code&gt;FileInputStream&lt;/code&gt;读取，然后再为目标文件构建一个&lt;code&gt;FileOutputStream&lt;/code&gt;，完成写入工作。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;copyFileByStream&lt;/span&gt;(File source, File dest) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;throws&lt;/span&gt; IOException {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;try&lt;/span&gt;(InputStream is = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; FileInputStream(source);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     OutputStream os = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; FileOutputStream(dest);) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;byte&lt;/span&gt;[] buffer = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;byte&lt;/span&gt;[1024];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; length;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt;((length = is.&lt;span style=&#34;color:#658b00&#34;&gt;read&lt;/span&gt;(buffer)) &amp;gt; 0) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      os.&lt;span style=&#34;color:#658b00&#34;&gt;write&lt;/span&gt;(buffer, 0, length);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;利用&lt;code&gt;java.nio&lt;/code&gt;类库提供的&lt;code&gt;transferTo&lt;/code&gt;或&lt;code&gt;transferFrom&lt;/code&gt;方法实现。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;copyFileByChannel&lt;/span&gt;(File source, Filr dest) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;throws&lt;/span&gt; IOException {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;try&lt;/span&gt;(FileChannel sourceChannel = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; FileInputStream(source).&lt;span style=&#34;color:#658b00&#34;&gt;getChannel&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      FileChannel targetChannel = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; FileOutputStream(dest).&lt;span style=&#34;color:#658b00&#34;&gt;getChannel&lt;/span&gt;();) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;long&lt;/span&gt; count = sourceChannel.&lt;span style=&#34;color:#658b00&#34;&gt;size&lt;/span&gt;(); count &amp;gt; 0; ) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;long&lt;/span&gt; transferred = sourceChannel.&lt;span style=&#34;color:#658b00&#34;&gt;transferTo&lt;/span&gt;(sourceChannel.&lt;span style=&#34;color:#658b00&#34;&gt;position&lt;/span&gt;(), count, targetChannel);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      count -= transferred;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;利用Java标准库本身提供的几种&lt;code&gt;File.copy&lt;/code&gt;实现。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一般来说，NIO的&lt;code&gt;transferTo/transferFrom&lt;/code&gt;的方式更快，因为它&lt;strong&gt;更能利用好现代操作系统的底层机制，避免不必要的拷贝和上下文切换&lt;/strong&gt;。&lt;/p&gt;- https://yuancode.net/posts/java/java_copy/ - 2022 ♾️ 杜宁元的Blog</description>
        </item>
    
    
    
        <item>
        <title>[Java] Exception和Error有什么区别？</title>
        <link>https://yuancode.net/posts/java/java_exception_and_error/</link>
        <pubDate>Thu, 28 Jul 2022 00:00:00 +0000</pubDate>
        
        <guid>https://yuancode.net/posts/java/java_exception_and_error/</guid>
        <description>💻元代码 https://yuancode.net/posts/java/java_exception_and_error/ -&lt;p&gt;&lt;strong&gt;请对比 Exception 和 Error，另外，运行时异常与一般异常有什么区别?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Exception&lt;/code&gt;和&lt;code&gt;Error&lt;/code&gt;都是继承了&lt;code&gt;Throwable&lt;/code&gt;类，在Java中只有Throwable类型的实例才可以被抛出(throw)或者捕获(catch)，它是异常处理机制的基本组成类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Exception&lt;/code&gt;和&lt;code&gt;Error&lt;/code&gt;体现了Java平台设计者对不同异常情况的分类。&lt;code&gt;Exception&lt;/code&gt;是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Error&lt;/code&gt;是指在正常情况下，不大可能出现的情况，绝大部分的Error都会导致程序（比如JVM自身）处于非正常的、不可恢复状态。既然是非正常情况，所以不便于也不需要捕获，常见的比如&lt;code&gt;OutOfMemoryError&lt;/code&gt;之类，都是&lt;code&gt;Error&lt;/code&gt;的子类。&lt;strong&gt;注意：&lt;code&gt;Error&lt;/code&gt;是&lt;code&gt;Throwable&lt;/code&gt;不是&lt;code&gt;Exception&lt;/code&gt;虽然它不可查。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Exception&lt;/code&gt;又分为&lt;strong&gt;受检查&lt;/strong&gt;(checked)异常和&lt;strong&gt;未检查&lt;/strong&gt;(unchecked)异常，&lt;strong&gt;可检查&lt;/strong&gt;异常在源代码里必须显示地进行捕获处理，这是编译期检查的一部分。&lt;/p&gt;
&lt;p&gt;不检查异常就是所谓的&lt;strong&gt;运行时异常&lt;/strong&gt;，类似&lt;code&gt;NullPointerException&lt;/code&gt;（空指针）、&lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt;（下标越界）之类，通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译期强制要求。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;strong&gt;扩展：&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;strong&gt;1. &lt;code&gt;NoClassDefFoundError&lt;/code&gt;和&lt;code&gt;ClassNotFoundException&lt;/code&gt;有什么区别？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NoClassDefFoundError&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;NoClassDefFoundError&lt;/code&gt;错误的发生是因为Java虚拟机在编译时能找到合适的类，而在运行时不能找到合适的类导致的错误。（类加载过程中没有办法找到对应的class文件。）比如编译通过后，手动删除引用的某个class文件、修改引用的jar包名称。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;NoClassDefFoundError&lt;/code&gt;是&lt;code&gt;Error&lt;/code&gt;，是&lt;strong&gt;未检查&lt;/strong&gt;（unchecked）异常，因此不需要使用&lt;code&gt;try-catch&lt;/code&gt;或者&lt;code&gt;finally&lt;/code&gt;语句块包裹。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;ClassNotFoundException&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;和编译期无关，当在代码中显示加载类（使用&lt;code&gt;Class.forName()&lt;/code&gt;&lt;!-- raw HTML omitted --&gt;1&lt;!-- raw HTML omitted --&gt;）时没有找到对应的类，则会抛出&lt;code&gt;ClassNotFoundException&lt;/code&gt;。例如加载SQL驱动时，对应的类加载器找不到驱动类。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ClassNotFoundException&lt;/code&gt;是&lt;strong&gt;受检查&lt;/strong&gt;（checked）异常，因此需要使用&lt;code&gt;try-catch&lt;/code&gt;或者&lt;code&gt;finally&lt;/code&gt;语句块包裹。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2. 这段代码反映了异常处理中哪些不当之处？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一段代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;try&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#228b22&#34;&gt;// 业务代码
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#228b22&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;  Thread.&lt;span style=&#34;color:#658b00&#34;&gt;sleep&lt;/span&gt;(1000L);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;catch&lt;/span&gt; (Exception e) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#228b22&#34;&gt;// Ignore it
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;第一，&lt;strong&gt;尽量不要捕获类似&lt;code&gt;Exception&lt;/code&gt;这样的通用异常，而是应该捕获特定异常&lt;/strong&gt;，&lt;code&gt;Thread.sleep()&lt;/code&gt;抛出的是&lt;code&gt;InterruptedException&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;日常开发和合作中，我们读代码的机会往往超过写代码，软件工程是门协作的艺术，所以我们有义务&lt;strong&gt;让自己的代码能够直观地体现出尽量多的信息&lt;/strong&gt;，而泛泛的&lt;code&gt;Exception&lt;/code&gt;之类，恰恰隐藏了我们的目的。另外，我们也要&lt;strong&gt;保证程序不会捕获到我们不希望捕获的异常&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第二，&lt;strong&gt;不要生吞（swallow）异常&lt;/strong&gt;。这是处理异常中要特别注意的事情，因为很可能会导致非常难以诊断的诡异情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二段代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;try&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#228b22&#34;&gt;// 业务代码
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#228b22&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;} &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;catch&lt;/span&gt; (IOException e) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  e.&lt;span style=&#34;color:#658b00&#34;&gt;printStackTrace&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这段代码作为一段实验代码，是没有任何问题的，但是在产品代码中，&lt;strong&gt;通常都不允许这样处理&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/9/docs/api/java/lang/Throwable.html#printStackTrace--&#34;&gt;printStackTrace()&lt;/a&gt;的文档开头写到“Prints this throwable and its backtrace to the standard error stream”。在稍微复杂一些的生产系统中，标准出错（STERR）不是个合适的输出选项，因为很难判断出到底输出到了哪里。&lt;/p&gt;
&lt;p&gt;尤其是对于&lt;strong&gt;分布式系统&lt;/strong&gt;，如果发生异常，但是无法找到堆栈轨迹（stacktrace），相当于为诊断设置障碍。因此，最好使用&lt;strong&gt;产品日志&lt;/strong&gt;，详细地输出到日志系统里。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Throw early, catch late原则：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;readPreferences&lt;/span&gt;(String fileName) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#228b22&#34;&gt;// ...perform operations
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;  InputStream in = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; FileInputStream(fileName);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#228b22&#34;&gt;// ...read the preferences file...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果&lt;code&gt;fullName&lt;/code&gt;是&lt;code&gt;null&lt;/code&gt;，那么程序会抛出&lt;code&gt;NullPointerException&lt;/code&gt;，但是没有第一时间暴露问题，堆栈信息可能让人费解。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;readPreferences&lt;/span&gt;(String fileName) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Objects.&lt;span style=&#34;color:#658b00&#34;&gt;requireNonNull&lt;/span&gt;(fileName);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#228b22&#34;&gt;// ...perform operations
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;  InputStream in = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; FileInputStream(fileName);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#228b22&#34;&gt;// ...read the preferences file...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;经过修改，问题便可以&amp;quot;&lt;code&gt;throw early&lt;/code&gt;&amp;quot;，对应的异常信息便非常直观了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;try-catch&lt;/code&gt;带来的开销：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;try-catch&lt;/code&gt;代码段会产生额外的性能开销，往往会影响JVM对代码进行优化，所以建议仅捕获有必要的代码段，尽量不要一个大的&lt;code&gt;try&lt;/code&gt;包住整段的代码；&lt;/p&gt;
&lt;p&gt;Java每实例化一个&lt;code&gt;Exception&lt;/code&gt;，都会对当时的栈进行快照，这是一个相对比较重的操作。如果发生的非常频繁，这个开销就不能被忽略了&lt;/p&gt;
&lt;p&gt;+++&lt;/p&gt;
&lt;p&gt;[1] Class.forName()：&lt;a href=&#34;https://blog.csdn.net/z13662788373/article/details/79457552&#34;&gt;Class.forName()用法详解&lt;/a&gt;&lt;/p&gt;- https://yuancode.net/posts/java/java_exception_and_error/ - 2022 ♾️ 杜宁元的Blog</description>
        </item>
    
    
    
        <item>
        <title>[Java] 强引用、软引用、弱引用、虚引用</title>
        <link>https://yuancode.net/posts/java/java_reference/</link>
        <pubDate>Thu, 28 Jul 2022 00:00:00 +0000</pubDate>
        
        <guid>https://yuancode.net/posts/java/java_reference/</guid>
        <description>💻元代码 https://yuancode.net/posts/java/java_reference/ -&lt;p&gt;在&lt;code&gt;JDK 1.2&lt;/code&gt;版本之后，Java对引用的概念进行了扩充，将引用分为强引用（Strongly Re-ference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;强引用、软引用、弱引用、幻象引用有什么区别?具体使用场景是
什么?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不同的引用类型，主要体现的是**对象不同的可达性（reachable）**状态和对垃圾收集的影响。&lt;/p&gt;
&lt;p&gt;强引用：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值。只要强引用关系还在，GC（垃圾收集器）就永远不会回收掉被引用的对象。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Java&#34; data-lang=&#34;Java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Object obj = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Object();
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;软引用：描述一些&lt;strong&gt;还有用，但非必须的对象&lt;/strong&gt;。将要发生内存溢出异常之前，会把这些对象列进回收范围之中进行第二次回收，如果此次回收还没有足够的内存，才会抛出内存溢出异常。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Java&#34; data-lang=&#34;Java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;// SoftReference实例来保存一个对象的软引用。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;SoftReference aSoftRef = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; SoftReference(aRef);  
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;弱引用：描述那些非必须对象，但是它的强度&lt;strong&gt;比软引用更弱一些&lt;/strong&gt;，只能生存到下一次垃圾收集发生为止。无论内存是否足够，都会回收掉只被弱引用关联的对象。&lt;/p&gt;
&lt;p&gt;虚引用：也称为“&lt;strong&gt;幽灵引用&lt;/strong&gt;”或者“&lt;strong&gt;幻影引用&lt;/strong&gt;”，不会影响对象生存时间。唯一目的：为了能在这个对象被收集器回收时收到一个系统通知。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;strong&gt;扩展：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;对象可达性状态流转&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;可达性级别（reachability level）：&lt;/p&gt;
&lt;p&gt;强可达（Strongly Reachable）：当一个对象可以有一个或多个线程可以不通过各种引用访问到的情况。&lt;/p&gt;
&lt;p&gt;软可达（Softly Reachable）：就是当我们只能通过软引用才能访问到对象的状态。&lt;/p&gt;
&lt;p&gt;弱可达（Weakly Reachable）：无法通过强引用或者软引用访问，只能通过弱引用访问时的状态。十分接近&lt;code&gt;finalize&lt;/code&gt;状态的时机，当弱引用被清除的时候，就符合&lt;code&gt;finalize&lt;/code&gt;的条件了。&lt;/p&gt;
&lt;p&gt;幻象可达/虚可达（Phantom Reachable）：没有强、软、弱引用关联，并且&lt;code&gt;finalize&lt;/code&gt;过了，只有虚引用指向这个对象的时候。&lt;/p&gt;
&lt;p&gt;不可达（unreachable）：对象可以被清除了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;判断对象可达性，是JVM垃圾收集器决定如何处理对象的一部分考虑。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;- https://yuancode.net/posts/java/java_reference/ - 2022 ♾️ 杜宁元的Blog</description>
        </item>
    
    
    
        <item>
        <title>[Java] 谈谈final、finally、finalize有什么不同？</title>
        <link>https://yuancode.net/posts/java/java_final_finally_finalize/</link>
        <pubDate>Thu, 28 Jul 2022 00:00:00 +0000</pubDate>
        
        <guid>https://yuancode.net/posts/java/java_final_finally_finalize/</guid>
        <description>💻元代码 https://yuancode.net/posts/java/java_final_finally_finalize/ -&lt;p&gt;&lt;strong&gt;谈谈&lt;code&gt;final&lt;/code&gt;、&lt;code&gt;finally&lt;/code&gt;、&lt;code&gt;finalize&lt;/code&gt;有什么不同？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;final&lt;/code&gt;：可以用来修饰类、方法、变量，分别有不同的意义：
&lt;ul&gt;
&lt;li&gt;类（&lt;code&gt;class&lt;/code&gt;）：不可以继承扩展&lt;/li&gt;
&lt;li&gt;方法：不可以重写（override）&lt;/li&gt;
&lt;li&gt;变量：不可以修改&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;finally&lt;/code&gt;：Java保证重点代码一定会被执行的一种机制。可以使用&lt;code&gt;try-finally&lt;/code&gt;或者&lt;code&gt;try-catch-finally&lt;/code&gt;来进行类似关闭JDBC连接、保证unlock锁等动作。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;finalize&lt;/code&gt;：是基础类&lt;code&gt;java.lang.Object&lt;/code&gt;的一个方法，它设计目的是保证对象在被垃圾收集前完成特定资源的回收。&lt;code&gt;finalize&lt;/code&gt;机制现在已经不推荐使用，并且在JDK 9开始被标记为&lt;code&gt;deprecated&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;final&lt;/code&gt;：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们可以将方法或者类声明为&lt;code&gt;final&lt;/code&gt;，这样可以明确告知别人，这些行为是不许修改的。&lt;/li&gt;
&lt;li&gt;有些Java类同样被声明为&lt;code&gt;final&lt;/code&gt;，这可以有效避免API使用者更改基础功能，某种程度上，这事保证平台安全的必要手段。
&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;final&lt;/code&gt;修饰参数或者变量，也可以清楚地避免意外赋值导致的编程错误。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;final&lt;/code&gt;变量产生了某种程度的不可变（&lt;code&gt;immutable&lt;/code&gt;）效果，所以，可以用于保护只读数据，尤其是在并发编程中，因为明确地不能再赋值&lt;code&gt;final&lt;/code&gt;变量，有利于减少额外的同步开销，也可以省去一些防御性拷贝的必要。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;finally&lt;/code&gt;的例外情况：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;try&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#228b22&#34;&gt;// do something
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;  System.&lt;span style=&#34;color:#658b00&#34;&gt;exit&lt;/span&gt;(1);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;finally&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  System.&lt;span style=&#34;color:#658b00&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;println&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Print from finally&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这段代码中的&lt;code&gt;finally&lt;/code&gt;并不会被执行，这与上面的&lt;em&gt;保证重点代码一定会被执行&lt;/em&gt;矛盾，这种情况属于特例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于&lt;code&gt;finalize&lt;/code&gt;：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;已不推荐使用。
&lt;ul&gt;
&lt;li&gt;简单来说，你无法保证&lt;code&gt;finalize&lt;/code&gt;什么时候执行，执行的是否符合预期。使用不当会影响性能，导致程序死锁、挂起等。&lt;/li&gt;
&lt;li&gt;回收资源可以选择上面提到的&lt;code&gt;try-with-resources&lt;/code&gt;或者&lt;code&gt;try-finally&lt;/code&gt;机制。如果确实需要额外处理，可以考虑Java提供的&lt;code&gt;Cleaner&lt;/code&gt;机制或者其他替代方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;扩展：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;final&lt;/code&gt;不是&lt;code&gt;immutable&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;final&lt;/code&gt;并不等同于&lt;code&gt;immutable&lt;/code&gt;&lt;/strong&gt;，比如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;final&lt;/span&gt; List&amp;lt;String&amp;gt; strLsit = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;strList.&lt;span style=&#34;color:#658b00&#34;&gt;add&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Hello&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;strList.&lt;span style=&#34;color:#658b00&#34;&gt;add&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;World&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;List&amp;lt;String&amp;gt; unmodifiableStrList = List.&lt;span style=&#34;color:#658b00&#34;&gt;of&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;world&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;unmodifiableStrList.&lt;span style=&#34;color:#658b00&#34;&gt;add&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;again&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;final&lt;/code&gt;只能约束&lt;code&gt;strList&lt;/code&gt;这个引用不可以被赋值，但是&lt;code&gt;strList&lt;/code&gt;对象行为不被&lt;code&gt;final&lt;/code&gt;影响，添加元素等操作是完全正常的。如果我们真的希望对象本身是不可变的，那么需要相应的类支持不可变的行为。&lt;/p&gt;
&lt;p&gt;上面的例子中，&lt;a href=&#34;https://openjdk.org/jeps/269&#34;&gt;List.of方法&lt;/a&gt;创建的本身就是不可变的List，第5行代码会导致在运行时抛出异常。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;某种意义上说，Java目前没有原生的不可变支持，如果要实现&lt;code&gt;immutable&lt;/code&gt;类，需要做到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将&lt;code&gt;class&lt;/code&gt;自身声明为&lt;code&gt;final&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;将所有成员变量定义为&lt;code&gt;private&lt;/code&gt;和&lt;code&gt;final&lt;/code&gt;，并且不实现&lt;code&gt;setter&lt;/code&gt;方法。&lt;/li&gt;
&lt;li&gt;通常构造对象时，成员变量使用深度拷贝来初始化，而不是直接赋值，这是一种防御措施，因为你无法确定输入对象不被其他人修改。&lt;/li&gt;
&lt;li&gt;如果确实要实现&lt;code&gt;getter&lt;/code&gt;方法，或者其他可能会返回内部状态的方法，使用&lt;code&gt;copy-on-write&lt;/code&gt;原则，创建私有的copy。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;finalize&lt;/code&gt;是否真的如此不堪？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;finalize&lt;/code&gt;的执行是和垃圾收集关联在一起的&lt;!-- raw HTML omitted --&gt;1&lt;!-- raw HTML omitted --&gt;，一旦实现非空的&lt;code&gt;finalize&lt;/code&gt;方法，就会导致相应对象回收呈现数量级上的变慢。&lt;/p&gt;
&lt;p&gt;因为&lt;code&gt;finalize&lt;/code&gt;被设计成在对象&lt;strong&gt;被垃圾收集前&lt;/strong&gt;调用，这就意味着实现了&lt;code&gt;finalize&lt;/code&gt;方法的对象是个“特殊公民”，JVM要对它进行额外处理。&lt;code&gt;finalize&lt;/code&gt;本质上成为了快速回收的阻碍者，可能导致对象经过多个垃圾收集周期才能被回收。&lt;/p&gt;
&lt;p&gt;即使我们使用&lt;code&gt;System.runFinalization()&lt;/code&gt;&lt;!-- raw HTML omitted --&gt;2&lt;!-- raw HTML omitted --&gt;主动告诉JVM积极一些，但是这种方式只能起到部分效果，&lt;code&gt;finalize&lt;/code&gt;仍然是不可预测、不能保证的。实践中，因为&lt;code&gt;finalize&lt;/code&gt;拖慢GC，导致大量对象堆积，也是一种典型的导致OOM的原因。&lt;/p&gt;
&lt;p&gt;从另一个角度，我们要确保回收资源就是因为资源是有限的，GC时间的不可预测，可能会极大加剧资源占用。这意味着对于消耗非常高频的资源，不可以期望&lt;code&gt;finalize&lt;/code&gt;来承担释放资源的主要职责，只能让其作为“守门员”。&lt;/p&gt;
&lt;p&gt;同时，&lt;code&gt;finalize&lt;/code&gt;海货掩盖资源回收出错时的出错信息：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;runFinalizer&lt;/span&gt;(JavaLangAccess jla) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#228b22&#34;&gt;// ... 省略部分代码
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;try&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Object finalizee = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;get&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(finalizee != &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !(finalizee &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;instanceof&lt;/span&gt; java.&lt;span style=&#34;color:#658b00&#34;&gt;lang&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;Enum&lt;/span&gt;)) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      jla.&lt;span style=&#34;color:#658b00&#34;&gt;invokeFinalize&lt;/span&gt;(finalizee);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#228b22&#34;&gt;// Clear stack slot containing this variable, to decrease
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;			&lt;span style=&#34;color:#228b22&#34;&gt;// the chances of false retention with a conservative GC
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;			finalizee = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;catch&lt;/span&gt; (Throwable x) { }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;super&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;clear&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;**Throwable被生吞（swallow）了。**这意味着一旦出现异常或者出错，将得不到任何有效信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有没有什么机制可以替代&lt;code&gt;finalize&lt;/code&gt;？&lt;/p&gt;
&lt;p&gt;Java目前正在逐步使用&lt;code&gt;java.lang.ref.Cleaner&lt;/code&gt;来替换掉原有的finalize实现。&lt;code&gt;Cleaner&lt;/code&gt;的实现利用了幻象引用（&lt;code&gt;PhantomReference&lt;/code&gt;），这事一种常见的所谓的&lt;code&gt;post-mortem&lt;/code&gt;清理机制。利用幻象引用和引用队列，可以保证对象被彻底销毁前做一些类似资源回收的工作（比如关闭文件描述符），它比&lt;code&gt;finalize&lt;/code&gt;更加轻量、更加可靠。&lt;/p&gt;
&lt;p&gt;每个&lt;code&gt;Cleaner&lt;/code&gt;的操作都是独立的，它有自己的运行线程，可以避免意外死锁。不过改善程度仍然有限，还是只适合作为一种最后的保证手段。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;+++&lt;/p&gt;
&lt;p&gt;[1] ：深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）第3章&lt;/p&gt;
&lt;p&gt;[2] System.runFinalization()：&lt;a href=&#34;https://blog.csdn.net/u014086926/article/details/52131857&#34;&gt;System.gc()和System.runFinalization()&lt;/a&gt;&lt;/p&gt;- https://yuancode.net/posts/java/java_final_finally_finalize/ - 2022 ♾️ 杜宁元的Blog</description>
        </item>
    
    
    
        <item>
        <title>[Java] 谈谈你对Java平台的理解？</title>
        <link>https://yuancode.net/posts/java/java_about_java/</link>
        <pubDate>Sun, 17 Jul 2022 00:00:00 +0000</pubDate>
        
        <guid>https://yuancode.net/posts/java/java_about_java/</guid>
        <description>💻元代码 https://yuancode.net/posts/java/java_about_java/ -&lt;p&gt;&lt;strong&gt;谈谈你对 Java 平台的理解?“Java 是解释执行”，这句话正确吗?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java本身是一种面向对象（继承、封装、多态）的语言，最显著的特性有两个方面：一是“编写一次，处处运行”(Write once, run anywhere)（JVM运行&lt;code&gt;.class&lt;/code&gt;文件），能够非常容易地获得跨平台能力；二是垃圾收集(GC, Garbage Collection)，Java通过垃圾收集器回收分配内存，大部分情况下，程序员不需要自己操心内存的分配和回收。&lt;/p&gt;
&lt;p&gt;“Java 是解释执行”这句话并不准确，Java源代码经过javac编译成.class字节码文件，.class字节码文件经过JVM解释或编译运行。JDK中提供了JIT(Just-In-Time)编译器，也就是通常所说的动态编译器，JIT能够在运行时将热点代码编译成与本地平台相关的机器码，这种情况下部分热点代码就属于==编译执行==，而不是解释执行。同时，Java9提供了AOT编译器，可以直接将所有代码编译成机器码执行。&lt;/p&gt;
&lt;p&gt;问题回答扩展：&lt;/p&gt;
&lt;p&gt;​	Java语言特性，包括泛型、Lambda等语言特性；&lt;/p&gt;
&lt;p&gt;​	基础类库，包括集合、IO/NIO、网络、并发、安全等基础类库；&lt;/p&gt;
&lt;p&gt;​	JVM的一些基础概念和机制，比如Java的类加载机制，常用版本JDK内嵌的Class-Loader，例如Bootstrap、Application和Extension Class-loader；&lt;/p&gt;
&lt;p&gt;​	类加载大致过程：加载、验证、链接、初始化；&lt;/p&gt;
&lt;p&gt;​	自定义Class-Loader；&lt;/p&gt;
&lt;p&gt;​	垃圾收集的基本原理，最常见的垃圾收集器，如SerialGC、Parallel GC、CMS、G1等，对于适用于什么样的工作负载最好也心里有数。&lt;/p&gt;- https://yuancode.net/posts/java/java_about_java/ - 2022 ♾️ 杜宁元的Blog</description>
        </item>
    
    
    
        <item>
        <title>[Java基础]int和Integer的区别</title>
        <link>https://yuancode.net/posts/java/java_int_and_integer/</link>
        <pubDate>Sun, 17 Jul 2022 00:00:00 +0000</pubDate>
        
        <guid>https://yuancode.net/posts/java/java_int_and_integer/</guid>
        <description>💻元代码 https://yuancode.net/posts/java/java_int_and_integer/ -&lt;p&gt;&lt;strong&gt;int和Integer有什么区别？谈谈Integer的值缓存范围。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Integer是int对应的包装类，它有一个int类型的字段存储数据，并且提供了基本操作，比如数学运算、int和字符串之间转换等。在&lt;code&gt;Java5&lt;/code&gt;中，引入了自动装箱和自动拆箱功能&lt;!-- raw HTML omitted --&gt;1&lt;!-- raw HTML omitted --&gt;（boxing/unboxing），Java可以根据上下文，自动进行转换，很大程度上简化了相关编程。&lt;/p&gt;
&lt;p&gt;int也就是Java中的整形数字，是Java的8个原始数据类型&lt;!-- raw HTML omitted --&gt;2&lt;!-- raw HTML omitted --&gt;,&lt;!-- raw HTML omitted --&gt;Java虽然号称一切都是对象，但是原始数据类型是例外&lt;!-- raw HTML omitted --&gt;。&lt;/p&gt;
&lt;p&gt;关于Integer的值缓存，涉及Java5中的另一个改进。构建Integer对象的传统方式是直接调用构造器new一个对象。但是大部分数据操作都是集中在有限的、较小的数值范围，因此在&lt;code&gt;Java5&lt;/code&gt;中新增了静态工厂方法&lt;!-- raw HTML omitted --&gt;3&lt;!-- raw HTML omitted --&gt;valueOf，在调用它的时候会利用一个缓存机制，带来明显的性能改进。值默认缓存范围是*-128到127之间*(2^8)。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;扩展：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Java对象的内存结构&lt;/p&gt;
&lt;p&gt;对象在内存中存储的布局可以分为3块区域：对象头、实例数据和对齐填充。&lt;/p&gt;
&lt;p&gt;对象头一般是十六个字节，包括两部分。&lt;/p&gt;
&lt;p&gt;​	第一部分：“Mark Word”，用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、现成持有的锁、偏向线程ID、偏向时间戳等。&lt;/p&gt;
&lt;p&gt;​	第二部分：类型指针，也就是对象指向它的类元数据指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。&lt;/p&gt;
&lt;p&gt;实例数据是对象存储的真正有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。&lt;/p&gt;
&lt;p&gt;对齐填充并不是必然存在的，起占位符的作用。因为HotSpot VM的 自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象大小必须是8字节的整数倍。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;+++&lt;/p&gt;
&lt;p&gt;[1] Java的自动装箱/拆箱功能：https://blog.csdn.net/qq_45570058/article/details/118929927  注意：发生在编译阶段。&lt;/p&gt;
&lt;p&gt;[2] Java的8个原始数据类型：boolean、char、byte、short、int、long、float、double。&lt;/p&gt;
&lt;p&gt;[3] 静态工厂方法：https://www.runoob.com/design-pattern/factory-pattern.html&lt;/p&gt;- https://yuancode.net/posts/java/java_int_and_integer/ - 2022 ♾️ 杜宁元的Blog</description>
        </item>
    
    
    
        <item>
        <title>[读书笔记]计算机组成与设计（RISC-V）第1章</title>
        <link>https://yuancode.net/posts/computer-organization-and-design-risc-v-edition-1/</link>
        <pubDate>Sat, 09 Jul 2022 00:00:00 +0000</pubDate>
        
        <guid>https://yuancode.net/posts/computer-organization-and-design-risc-v-edition-1/</guid>
        <description>💻元代码 https://yuancode.net/posts/computer-organization-and-design-risc-v-edition-1/ -&lt;p&gt;第1章主要是为其余章节奠定基础。介绍了基本概念和定义，对软件和硬件的主要组成部分进行了剖析，展示了如何评估性能和功耗，介绍了集成电路（推动计算机革命的基数），并在最后解释了技术向多核转变的原因。&lt;/p&gt;
&lt;p&gt;以下摘自本书引言部分：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在你读完这本书的时候，我们相信你能够回答以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用C或Java等高级语言编写的程序如何被翻译成机器语言，以及硬件如何执行最终的程序？这些概念是理解软硬件如何影响程序性能的基础。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;软件和硬件之间的接口是什么？软件如何指导硬件执行所需的功能？这些概念对理解如何编写软件是至关重要的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;什么因素决定了程序的性能，以及程序员如何改进程序性能？我们将从本书知道，这
取决于原始程序、将该程序转换成计算机语言的软件以及硬件执行该程序的有效性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;硬件设计人员可以使用哪些技术来改善能效？程序员可以做些什么来改变能效？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;串行处理近来发展到并行处理的原因和结果是什么？本书给出了这一发展变化的动机，描述了当前支持并行的硬件机制，并评述了新一代*“多核”微处理器*（见第6章)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自1951 年第一台商用计算机以来，计算机架构师提出的哪些伟大思想奠定了现代计算技术的基础？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;第1章-计算机抽象及相关技术&#34;&gt;第1章 计算机抽象及相关技术&lt;/h1&gt;
&lt;h2 id=&#34;计算机体系结构中的8个伟大思想&#34;&gt;计算机体系结构中的8个伟大思想&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;面向摩尔定律的设计&lt;/p&gt;
&lt;p&gt;​	摩尔定律：由Intel公司的创始人之一戈登·摩尔在1965年提出，指出单芯片上所集成的晶体管资源每18至24个月翻一番。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.so.studiodahu.com/wiki/%E6%91%A9%E5%B0%94%E5%AE%9A%E5%BE%8B&#34;&gt;摩尔定律 - 维基百科&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用抽象简化设计&lt;/p&gt;
&lt;p&gt;​	提高硬件和软件生产率的主要技术之一是使用抽象（abstraction）来表示不同的设计层次——隐藏底层细节以提供给高层一个更简单的模型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加速经常性事件&lt;/p&gt;
&lt;p&gt;简单的说就是优化调用最频繁的代码/函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过并行提高性能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过流水线（pipelining）提高性能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过预测提高性能&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;​	在某些情况下，假设从预测错误中恢复的代价并不高，且预测相对准确，则平均来说进行预测并开始工作可能会比等到明确结果后再执行更快。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;存储层次&lt;/p&gt;
&lt;p&gt;​	程序员希望存储器速度更快、容量更大、价格更便宜。但是这些需求在目前来说是冲突的。架构师发现可以通过存储层次（hierarchy of memory）来处理这些冲突的需求。速度最快、容量最小并且每位价格最昂贵的存储器处于顶层，而速度最慢、容量最大且每位价格最便宜的存储器处于底层。&lt;/p&gt;
&lt;p&gt;​	这样组织的好处是，高速缓存可以给程序员这样的错觉：主存与存储层次几乎一样快，且与存储层次底层拥有几乎样大的容量和便宜的价格。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过冗余提高可靠性&lt;/p&gt;
&lt;p&gt;​	通过引入冗余组件来使系统可靠，该组件在系统发生故障时可以替代失效组件并帮助检测故障。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;- https://yuancode.net/posts/computer-organization-and-design-risc-v-edition-1/ - 2022 ♾️ 杜宁元的Blog</description>
        </item>
    
    
  </channel>
</rss> 